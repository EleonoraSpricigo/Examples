# Import Python libraries
import os, pickle
import numpy as np

# Import Kratos
import KratosMultiphysics
import KratosMultiphysics.MultilevelMonteCarloApplication
import KratosMultiphysics.MappingApplication

# Importing the problem analysis stage class
from FluidDynamicsAnalysisMC import FluidDynamicsAnalysisMC
from KratosMultiphysics.FluidDynamicsApplication import check_and_prepare_model_process_fluid

# Avoid printing of Kratos informations
KratosMultiphysics.Logger.GetDefaultOutput().SetSeverity(KratosMultiphysics.Logger.Severity.WARNING)


class SimulationScenario(FluidDynamicsAnalysisMC):
    def __init__(self,input_model,input_parameters,sample):
        super().__init__(input_model,input_parameters)
        self.sample = sample
        self.mapping = False
        self.interest_model_part = "FluidModelPart.NoSlip3D_No_Slip_Building"
        self.number_instances_time_power_sums = 0
        self.IsVelocityFieldPerturbed = False
        self.filename = "filename"

    def ModifyInitialProperties(self):
        """
        function changing print to file settings
        input:  self: an instance of the class
        """
        super().ModifyInitialProperties()
        # add capability of saving force and moment time series
        raw_path, raw_filename = os.path.split(self.filename)
        self.project_parameters["processes"]["auxiliar_process_list"][0]["Parameters"]["write_drag_output_file"].SetBool(True)
        self.project_parameters["processes"]["auxiliar_process_list"][0]["Parameters"]["output_file_settings"]["file_name"].SetString(raw_filename)
        self.project_parameters["processes"]["auxiliar_process_list"][0]["Parameters"]["output_file_settings"]["output_path"].SetString(raw_path)
        if (self.project_parameters["problem_data"]["perturbation"]["type"].GetString() == "correlated"):
            if type(self.sample[-1]) is int:
                # for MC + ensemble average
                # self.project_parameters["processes"]["initial_conditions_process_list"][0]["Parameters"]["seed"].SetInt(self.sample[-1])
                pass
        # introduce stochasticity in inlet
        # we consider the wind seed as random variable only if reference velocity and roughness height are constant
        # otherwise we consider the wind seed only for generating different evolutions to run ensemble average
        # and therefore we use the seed generated by the KratosSolverWrapper
        if not (self.project_parameters["problem_data"]["random_roughness_height"].GetBool() or self.project_parameters["problem_data"]["random_reference_velocity"].GetBool()):
            self.project_parameters["processes"]["boundary_conditions_process_list"][0]["Parameters"]["seed"].SetInt(self.sample[0])
        else:
            pass
            # uncomment following lines if we want to change the seed of the wind generator
            # for running different ensembles with different wind generator seed
            # for the same mean wind profile
            if type(self.sample[-1]) is int:
                self.project_parameters["processes"]["boundary_conditions_process_list"][0]["Parameters"]["seed"].SetInt(self.sample[-1])
        if self.project_parameters["problem_data"]["random_reference_velocity"].GetBool():
            print("[SCREENING] modifying reference velocity")
            random_umean = max(0.1,self.sample[1]) # ensure not having negative velocity
            self.project_parameters["processes"]["boundary_conditions_process_list"][0]["Parameters"]["umean"].SetDouble(random_umean)
        if self.project_parameters["problem_data"]["random_roughness_height"].GetBool():
            print("[SCREENING] modifying roughness height")
            self.project_parameters["processes"]["boundary_conditions_process_list"][0]["Parameters"]["roughness_height"].SetDouble(self.sample[2])
        print("\nRandom variables:", self.sample)
        print("RVs set in the json:")
        print("Reference velocity:",self.project_parameters["processes"]["boundary_conditions_process_list"][0]["Parameters"]["umean"].GetDouble())
        print("Roughness height:",self.project_parameters["processes"]["boundary_conditions_process_list"][0]["Parameters"]["roughness_height"].GetDouble())
        print("Seed wind generator:",self.project_parameters["processes"]["boundary_conditions_process_list"][0]["Parameters"]["seed"].GetInt())
        # print("Seed initial conditions:",self.project_parameters["processes"]["initial_conditions_process_list"][0]["Parameters"]["seed"].GetInt())
        print("\n")

    def ApplyBoundaryConditions(self):
        """
        function introducing the stochasticity in the problem
        input:  self: an instance of the class
        """
        super().ApplyBoundaryConditions()
        if (self.IsVelocityFieldPerturbed is False) and (self.project_parameters["problem_data"]["perturbation"]["type"].GetString() == "uncorrelated"):
            if type(self.sample[-1]) is int:
                print("[SCREENING] setting seed in ApplyBoundaryConditions method. Seed =", self.sample[-1])
                np.random.RandomState(seed=self.sample[-1])
            print("[SCREENING] perturbing the domain:","Yes")
            self.main_model_part = self.model.GetModelPart("FluidModelPart")
            # load velocity field
            with open("average_velocity_field_CAARC_3d_combinedPressureVelocity_283k_690.0.dat") as dat_file:
                lines=dat_file.readlines()
                # store velocity field in a dictionary
                avg_velocity_dict = {}
                for id, line in enumerate (lines):
                    # +1 since enumerate starts from 0 and Kratos starts from 1
                    avg_velocity_dict[id+1] = {"velocity_x": float(line.split(' ')[0]), "velocity_y": float(line.split(' ')[1]), "velocity_z": float(line.split(' ')[2])}
                # read nodes of the model part
                # observe that nodes of each model part will be different for each rank
                for node in self.main_model_part.Nodes:
                    if not (node.IsFixed(KratosMultiphysics.VELOCITY_X) or node.IsFixed(KratosMultiphysics.VELOCITY_Y) or node.IsFixed(KratosMultiphysics.VELOCITY_Z) or node.IsFixed(KratosMultiphysics.PRESSURE)):
                        # retrieve velocity
                        velocity = KratosMultiphysics.Vector(3, 0.0)
                        velocity[0] = avg_velocity_dict[int(node.Id)]["velocity_x"]
                        velocity[1] = avg_velocity_dict[int(node.Id)]["velocity_y"]
                        velocity[2] = avg_velocity_dict[int(node.Id)]["velocity_z"]
                        # compute uncorrelated perturbation
                        perturbation_intensity = self.project_parameters["problem_data"]["perturbation"]["intensity"].GetDouble()
                        if perturbation_intensity > 1: # perturbation intensity is absolute
                            perturbation = np.random.uniform(-perturbation_intensity,perturbation_intensity,3)
                        else: # perturbation intensity is relative wrt velocity
                            perturbation = np.random.uniform(-perturbation_intensity,perturbation_intensity,3) * velocity.norm_2() # all nodes and directions different value
                        # sum avg velocity and perturbation
                        velocity[0] = velocity[0] + perturbation[0]
                        velocity[1] = velocity[1] + perturbation[1]
                        velocity[2] = velocity[2] + perturbation[2]
                        node.SetSolutionStepValue(KratosMultiphysics.VELOCITY, 1, velocity)
                        node.SetSolutionStepValue(KratosMultiphysics.VELOCITY, velocity)
            self.IsVelocityFieldPerturbed = True
        else:
            print("[SCREENING] perturbing the domain:", "No")

    def ComputeNeighbourElements(self):
        """
        function computing neighbour elements, required by our boundary conditions
        input:  self: an instance of the class
        """
        tmoc = KratosMultiphysics.TetrahedralMeshOrientationCheck
        throw_errors = False
        flags = (tmoc.COMPUTE_NODAL_NORMALS).AsFalse() | (tmoc.COMPUTE_CONDITION_NORMALS).AsFalse()
        flags |= tmoc.ASSIGN_NEIGHBOUR_ELEMENTS_TO_CONDITIONS
        KratosMultiphysics.TetrahedralMeshOrientationCheck(self._GetSolver().main_model_part.GetSubModelPart("fluid_computational_model_part"),throw_errors, flags).Execute()

    def Initialize(self):
        """
        function initializing moment estimator array
        input:  self: an instance of the class
        """
        super().Initialize()
        # compute neighbour elements required for current boundary conditions and not automatically run due to remeshing
        self.ComputeNeighbourElements()
        # initialize moment estimator array for each qoi to build time power sums
        self.moment_estimator_array = [[[0.0],[0.0],[0.0],[0.0],[0.0],[0.0],[0.0],[0.0],[0.0],[0.0]] for _ in range (0,2)] # +2 is for drag force x and base moment z
        if (self.mapping is True):
            power_sums_parameters = KratosMultiphysics.Parameters("""{
                "reference_variable_name": "PRESSURE"
                }""")
            self.power_sums_process_mapping = KratosMultiphysics.MultilevelMonteCarloApplication.PowerSumsStatistics(self.mapping_reference_model.GetModelPart(self.interest_model_part),power_sums_parameters)
            self.power_sums_process_mapping.ExecuteInitialize()
            print("[SCREENING] number nodes of submodelpart + drag force x + base moment z:",self.mapping_reference_model.GetModelPart(self.interest_model_part).NumberOfNodes()+2) # +2 is for drag coefficient and base moment z
        else:
            power_sums_parameters = KratosMultiphysics.Parameters("""{
                "reference_variable_name": "PRESSURE"
                }""")
            self.power_sums_process = KratosMultiphysics.MultilevelMonteCarloApplication.PowerSumsStatistics(self.model.GetModelPart(self.interest_model_part),power_sums_parameters)
            self.power_sums_process.ExecuteInitialize()
            print("[SCREENING] number nodes of submodelpart + drag + base moment z:",self.model.GetModelPart(self.interest_model_part).NumberOfNodes()+2) # +2 is for drag coefficient and base moment z
        print("[SCREENING] mapping flag:",self.mapping)

    def FinalizeSolutionStep(self):
        """
        function applying mapping if required and updating moment estimator array
        input:  self: an instance of the class
        """
        super().FinalizeSolutionStep()
        # run if current index is index of interest
        if (self.is_current_index_maximum_index is True):
            # avoid burn-in time
            if (self.model.GetModelPart(self.interest_model_part).ProcessInfo.GetPreviousTimeStepInfo().GetValue(KratosMultiphysics.TIME) >= \
                self.project_parameters["problem_data"]["burnin_time"].GetDouble()):
                # update number of contributions to time power sums
                self.number_instances_time_power_sums = self.number_instances_time_power_sums + 1
                # update power sums of drag force x and base moment z
                self.moment_estimator_array[0][0][0] = self.moment_estimator_array[0][0][0] + self.current_drag_force_x
                self.moment_estimator_array[0][1][0] = self.moment_estimator_array[0][1][0] + self.current_drag_force_x**2
                self.moment_estimator_array[0][2][0] = self.moment_estimator_array[0][2][0] + self.current_drag_force_x**3
                self.moment_estimator_array[0][3][0] = self.moment_estimator_array[0][3][0] + self.current_drag_force_x**4
                self.moment_estimator_array[0][4][0] = self.moment_estimator_array[0][4][0] + self.current_drag_force_x**5
                self.moment_estimator_array[0][5][0] = self.moment_estimator_array[0][5][0] + self.current_drag_force_x**6
                self.moment_estimator_array[0][6][0] = self.moment_estimator_array[0][6][0] + self.current_drag_force_x**7
                self.moment_estimator_array[0][7][0] = self.moment_estimator_array[0][7][0] + self.current_drag_force_x**8
                self.moment_estimator_array[0][8][0] = self.moment_estimator_array[0][8][0] + self.current_drag_force_x**9
                self.moment_estimator_array[0][9][0] = self.moment_estimator_array[0][9][0] + self.current_drag_force_x**10
                self.moment_estimator_array[1][0][0] = self.moment_estimator_array[1][0][0] + self.current_base_moment_z
                self.moment_estimator_array[1][1][0] = self.moment_estimator_array[1][1][0] + self.current_base_moment_z**2
                self.moment_estimator_array[1][2][0] = self.moment_estimator_array[1][2][0] + self.current_base_moment_z**3
                self.moment_estimator_array[1][3][0] = self.moment_estimator_array[1][3][0] + self.current_base_moment_z**4
                self.moment_estimator_array[1][4][0] = self.moment_estimator_array[1][4][0] + self.current_base_moment_z**5
                self.moment_estimator_array[1][5][0] = self.moment_estimator_array[1][5][0] + self.current_base_moment_z**6
                self.moment_estimator_array[1][6][0] = self.moment_estimator_array[1][6][0] + self.current_base_moment_z**7
                self.moment_estimator_array[1][7][0] = self.moment_estimator_array[1][7][0] + self.current_base_moment_z**8
                self.moment_estimator_array[1][8][0] = self.moment_estimator_array[1][8][0] + self.current_base_moment_z**9
                self.moment_estimator_array[1][9][0] = self.moment_estimator_array[1][9][0] + self.current_base_moment_z**10
                if (self.mapping is True):
                    # call parallel fill communicator
                    ParallelFillCommunicator = KratosMultiphysics.mpi.ParallelFillCommunicator(self.mapping_reference_model.GetModelPart("FluidModelPart"))
                    ParallelFillCommunicator.Execute()
                    # mapping from current model part of interest to reference model part the pressure
                    mapping_parameters = KratosMultiphysics.Parameters("""{
                        "mapper_type": "nearest_element",
                        "interface_submodel_part_origin": "FluidModelPart.NoSlip3D_structure",
                        "interface_submodel_part_destination": "FluidModelPart.NoSlip3D_structure",
                        "echo_level" : 3
                        }""")
                    mapper = KratosMultiphysics.MappingApplication.MPIExtension.MPIMapperFactory.CreateMapper(self._GetSolver().main_model_part,self.mapping_reference_model.GetModelPart("FluidModelPart"),mapping_parameters)
                    mapper.Map(KratosMultiphysics.PRESSURE,KratosMultiphysics.PRESSURE)
                    # pressure field power sums
                    self.power_sums_process_mapping.ExecuteFinalizeSolutionStep()
                else:
                    # update pressure field power sums
                    self.power_sums_process.ExecuteFinalizeSolutionStep()
        else:
            pass

    def EvaluateQuantityOfInterest(self):
        """
        function evaluating the QoI of the problem: lift coefficient
        input:  self: an instance of the class
        """
        communicator = KratosMultiphysics.DataCommunicator.GetDefault()
        rank = communicator.Rank()
        # run if current index is index of interest
        if (self.is_current_index_maximum_index is True):
            print("[SCREENING] computing qoi current index:",self.is_current_index_maximum_index)
            qoi_list = []
            # append time average drag force
            qoi_list.append(self.mean_drag_force_x)
            # append time averaged base moment_z
            qoi_list.append(self.mean_base_moment_z)
            # append time average pressure
            if (self.mapping is not True):
                model_part_of_interest = self.model.GetModelPart(self.interest_model_part)
            elif (self.mapping is True):
                model_part_of_interest = self.mapping_reference_model.GetModelPart(self.interest_model_part)
            pressure_list = \
                [node.GetValue(KratosMultiphysics.ExaquteSandboxApplication.AVERAGED_PRESSURE) for node in model_part_of_interest.Nodes if node.GetSolutionStepValue(KratosMultiphysics.PARTITION_INDEX)==rank]
            pressure_list_new = []
            qoi_averaged_pressure = []
            if rank==0:
                pressure_list_new = communicator.GathervDoubles(pressure_list, 0)
            else:
                communicator.GathervDoubles(pressure_list, 0)
            if rank==0:
                for list_pressure in pressure_list_new:
                    qoi_averaged_pressure.extend(list_pressure)
            qoi_list.append(qoi_averaged_pressure)
            # append number of contributions to the power sums list
            self.moment_estimator_array[0].append(self.number_instances_time_power_sums) # drag force x
            self.moment_estimator_array[1].append(self.number_instances_time_power_sums) # base moment z
            # append drag force x and base moment z time series power sums
            qoi_list.append(self.moment_estimator_array[0]) # drag force x
            qoi_list.append(self.moment_estimator_array[1]) # base moment z
            # append pressure time series power sums
            pressure_power_sums_list = []
            for node in model_part_of_interest.Nodes:
                if node.GetSolutionStepValue(KratosMultiphysics.PARTITION_INDEX) == rank:
                    S1 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_1)
                    S2 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_2)
                    S3 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_3)
                    S4 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_4)
                    S5 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_5)
                    S6 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_6)
                    S7 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_7)
                    S8 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_8)
                    S9 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_9)
                    S10 = node.GetValue(KratosMultiphysics.MultilevelMonteCarloApplication.POWER_SUM_10)
                    M = self.number_instances_time_power_sums
                    power_sums = [[S1],[S2],[S3],[S4],[S5],[S6],[S7],[S8],[S9],[S10],M]
                    pressure_power_sums_list.append(power_sums)
            string_to_send = pickle.dumps(pressure_power_sums_list, 2).decode("latin1")
            pressure_power_sums_list_new = []
            if rank==0:
                pressure_power_sums_list_new.extend(pressure_power_sums_list)
                for rank_recv in range(1, communicator.Size()):
                    pickled_list = communicator.SendRecvString(string_to_send, rank_recv, rank_recv)
                    list_to_extend = pickle.loads(pickled_list.encode("latin1"))
                    pressure_power_sums_list_new.extend(list_to_extend)
            else:
                pickled_list = communicator.SendRecvString(string_to_send, 0, 0)
            qoi_list.append(pressure_power_sums_list_new)

            # save coordinates
            coord_list_1 = []; coord_list_2 = []; coord_list_3 = []; coord_list_4 = []
            for node in model_part_of_interest.Nodes:
                if node.GetSolutionStepValue(KratosMultiphysics.PARTITION_INDEX) == rank:
                    coord_list_1.append(node.Id); coord_list_2.append(node.X); coord_list_3.append(node.Y); coord_list_4.append(node.Z)
            coord_list_1_new = []; coord_list_2_new = []; coord_list_3_new = []; coord_list_4_new = []
            if rank==0:
                coord_list_1_new = communicator.GathervDoubles(coord_list_1, 0); coord_list_2_new = communicator.GathervDoubles(coord_list_2, 0); coord_list_3_new = communicator.GathervDoubles(coord_list_3, 0); coord_list_4_new = communicator.GathervDoubles(coord_list_4, 0)
            else:
                communicator.GathervDoubles(coord_list_1, 0); communicator.GathervDoubles(coord_list_2, 0); communicator.GathervDoubles(coord_list_3, 0); communicator.GathervDoubles(coord_list_4, 0)
            qoi_coord_1 = []; qoi_coord_2 = []; qoi_coord_3 = []; qoi_coord_4 = []
            if rank==0:
                for coord_aux in coord_list_1_new:
                    qoi_coord_1.extend(coord_aux)
                for coord_aux in coord_list_2_new:
                    qoi_coord_2.extend(coord_aux)
                for coord_aux in coord_list_3_new:
                    qoi_coord_3.extend(coord_aux)
                for coord_aux in coord_list_4_new:
                    qoi_coord_4.extend(coord_aux)
            qoi_list.append(qoi_coord_1)
            qoi_list.append(qoi_coord_2)
            qoi_list.append(qoi_coord_3)
            qoi_list.append(qoi_coord_4)

            print("SYNCINFO: number of QoIs", len(qoi_list))
            # qoi_list is complete only in rank 0
            # we synchronize with other ranks
            string_to_send_qoi = pickle.dumps(qoi_list, 2).decode("latin1")
            if rank==0:
                for rank_recv in range(1, communicator.Size()):
                    pickled_list_qoi = communicator.SendRecvString(string_to_send_qoi, rank_recv, rank_recv)
            else:
                pickled_list_qoi = communicator.SendRecvString(string_to_send_qoi, 0, 0)
                qoi_list = pickle.loads(pickled_list_qoi.encode("latin1"))
        else:
            print("[SCREENING] computing qoi current index:",self.is_current_index_maximum_index)
            qoi_list = None
        # print("[SCREENING] qoi list:",qoi_list)
        return qoi_list

    def MappingAndEvaluateQuantityOfInterest(self):
        """
        function mapping the weighted pressure on reference model and calling evaluation of quantit of interest
        input:  self: an instance of the class
        """
        # call parallel fill communicator
        ParallelFillCommunicator = KratosMultiphysics.mpi.ParallelFillCommunicator(self.mapping_reference_model.GetModelPart("FluidModelPart"))
        ParallelFillCommunicator.Execute()
        # map from current model part of interest to reference model part
        mapping_parameters = KratosMultiphysics.Parameters("""{
            "mapper_type": "nearest_element",
            "interface_submodel_part_origin": "FluidModelPart.NoSlip3D_No_Slip_Building",
            "interface_submodel_part_destination": "FluidModelPart.NoSlip3D_No_Slip_Building",
            "echo_level" : 3
            }""")
        mapper = KratosMultiphysics.MappingApplication.MPIExtension.MPIMapperFactory.CreateMapper(self._GetSolver().main_model_part,self.mapping_reference_model.GetModelPart("FluidModelPart"),mapping_parameters)
        mapper.Map(KratosMultiphysics.ExaquteSandboxApplication.AVERAGED_PRESSURE, \
            KratosMultiphysics.ExaquteSandboxApplication.AVERAGED_PRESSURE,        \
            KratosMultiphysics.MappingApplication.Mapper.FROM_NON_HISTORICAL |     \
            KratosMultiphysics.MappingApplication.Mapper.TO_NON_HISTORICAL)
        # evaluate qoi
        qoi_list = self.EvaluateQuantityOfInterest()
        return qoi_list
